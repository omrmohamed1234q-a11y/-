import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from './use-auth';
import { useQueryClient } from '@tanstack/react-query';
import { useToast } from './use-toast';
import { supabase } from '@/lib/supabase';

interface WebSocketMessage {
  type: string;
  data?: any;
  timestamp?: number;
  message?: string;
  connectionId?: string;
  userId?: string;
  userType?: string;
  orderId?: string;
}

interface WebSocketState {
  isConnected: boolean;
  isConnecting: boolean;
  connectionId?: string;
  error?: string;
  lastPing?: number;
}

interface WebSocketHook {
  state: WebSocketState;
  sendMessage: (message: WebSocketMessage) => void;
  subscribeToOrderUpdates: (orderId: string) => void;
  updateDriverLocation: (latitude: number, longitude: number, orderId?: string) => void;
  broadcastOrderStatusUpdate: (orderId: string, status: string, statusText: string, additionalData?: any) => void;
  disconnect: () => void;
  reconnect: () => void;
}

export function useWebSocket(): WebSocketHook {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Handle notification message  
  // Request notification permission on first use
  const requestNotificationPermission = useCallback(async () => {
    if ('Notification' in window && Notification.permission === 'default') {
      try {
        const permission = await Notification.requestPermission();
        console.log('üîî Notification permission:', permission);
      } catch (error) {
        console.log('‚ö†Ô∏è Failed to request notification permission:', error);
      }
    }
  }, []);

  const handleNotificationMessage = useCallback((notification: any) => {
    if (!notification) return;

    console.log('üîî Real-time notification received:', notification);

    // Invalidate notification queries to refresh data
    queryClient.invalidateQueries({ queryKey: ['/api/notifications'] });
    queryClient.invalidateQueries({ queryKey: ['/api/notifications/unread-count'] });

    // Show toast notification if priority is high or urgent
    if (notification.priority === 'high' || notification.priority === 'urgent') {
      toast({
        title: notification.title,
        description: notification.message,
        duration: notification.priority === 'urgent' ? 10000 : 5000,
      });
    }

    // Trigger browser notification if permissions granted
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(notification.title, {
        body: notification.message,
        icon: '/favicon.ico',
        badge: '/favicon.ico',
        tag: notification.id,
        requireInteraction: notification.priority === 'urgent'
      });
    }
  }, [queryClient, toast]);
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimerRef = useRef<NodeJS.Timeout | null>(null);
  const pingIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const [state, setState] = useState<WebSocketState>({
    isConnected: false,
    isConnecting: false
  });

  // Get authentication token for WebSocket connection
  const getAuthToken = useCallback(async () => {
    // Check localStorage first (for admin users)
    const storedToken = localStorage.getItem('token');
    if (storedToken) {
      return storedToken;
    }
    
    // Fall back to Supabase session for regular users
    try {
      const { data: { session } } = await supabase.auth.getSession();
      return session?.access_token || null;
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to get auth token:', error);
      return null;
    }
  }, []);

  // ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ™ÿµÿßŸÑ WebSocket - RE-ENABLED after fixing auth issues
  const connect = useCallback(() => {

    if (wsRef.current?.readyState === WebSocket.CONNECTING || 
        wsRef.current?.readyState === WebSocket.OPEN) {
      return;
    }

    setState(prev => ({ ...prev, isConnecting: true, error: undefined }));
    console.log('üîó Connecting to WebSocket...');

    try {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const wsUrl = `${protocol}//${window.location.host}/ws`;
      
      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;

      ws.onopen = async () => {
        console.log('‚úÖ WebSocket connected successfully');
        setState(prev => ({
          ...prev,
          isConnected: true,
          isConnecting: false,
          error: undefined
        }));

        // Request notification permission
        requestNotificationPermission();

        // ŸÖÿµÿßÿØŸÇÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ™ÿßÿ≠ÿßŸã ŸÖÿπ JWT token
        if (user) {
          const token = await getAuthToken();
          
          // Only authenticate if we have a valid JWT token
          if (token && token !== 'temp-token') {
            const authMessage: WebSocketMessage = {
              type: 'authenticate',
              data: {
                userId: user.id,
                userType: 'customer',
                token: token
              }
            };
            ws.send(JSON.stringify(authMessage));
          } else {
            console.log('‚ö†Ô∏è No valid JWT token available for WebSocket authentication');
            // Close connection if no valid token
            setState(prev => ({
              ...prev,
              error: 'ŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ ÿµÿßŸÑÿ≠ ŸÑŸÑÿßÿ™ÿµÿßŸÑ'
            }));
            ws.close(4001, 'Authentication required');
          }
        }

        // ÿ®ÿØÿ° ping ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ
        startPing();
      };

      ws.onmessage = (event) => {
        try {
          const message: WebSocketMessage = JSON.parse(event.data);
          console.log('üì® WebSocket message received:', message);

          switch (message.type) {
            case 'notification':
              handleNotificationMessage(message.data);
              break;
              
            case 'welcome':
              setState(prev => ({
                ...prev,
                connectionId: message.connectionId
              }));
              break;

            case 'authenticated':
              console.log('‚úÖ WebSocket authentication successful');
              break;

            case 'pong':
              setState(prev => ({
                ...prev,
                lastPing: Date.now()
              }));
              break;

            case 'order_status_update':
              // ÿ®ÿ´ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ® ŸÑŸÑŸÖŸÉŸàŸÜÿßÿ™ ÿßŸÑŸÖŸáÿ™ŸÖÿ©
              window.dispatchEvent(new CustomEvent('orderStatusUpdate', {
                detail: message.data
              }));
              break;

            case 'driver_location_update':
              // ÿ®ÿ´ ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑŸÉÿßÿ®ÿ™ŸÜ
              window.dispatchEvent(new CustomEvent('driverLocationUpdate', {
                detail: message.data
              }));
              break;


            default:
              console.log(`‚ùì Unknown message type: ${message.type}`);
          }
        } catch (error) {
          console.error('‚ùå Error parsing WebSocket message:', error);
        }
      };

      ws.onclose = (event) => {
        console.log(`‚ùå WebSocket connection closed:`, event.code, event.reason);
        setState(prev => ({
          ...prev,
          isConnected: false,
          isConnecting: false
        }));

        stopPing();

        // FIXED: Stop authentication loop - don't reconnect on auth failures
        const isNormalClosure = event.code === 1000;
        const isAuthFailure = event.code === 4001 || event.code === 4000;
        const isInvalidToken = event.reason === 'Authentication required';
        
        // Only reconnect if it's not a normal closure and not an auth failure
        if (!isNormalClosure && !isAuthFailure && !isInvalidToken) {
          console.log('üîÑ Network error detected - scheduling reconnect');
          scheduleReconnect();
        } else if (isAuthFailure || isInvalidToken) {
          console.warn('üö´ AUTHENTICATION FAILED - Connection stopped permanently');
          console.warn('üö´ Please login again to restore WebSocket connection');
          
          // Clear any pending reconnection attempts
          if (reconnectTimerRef.current) {
            clearTimeout(reconnectTimerRef.current);
            reconnectTimerRef.current = null;
          }
          
          setState(prev => ({
            ...prev,
            error: 'Authentication required - please login again'
          }));
        } else {
          console.log('üîå WebSocket connection closed normally - no reconnection needed');
        }
      };

      ws.onerror = (error) => {
        console.error('üí• WebSocket error:', error);
        setState(prev => ({
          ...prev,
          isConnected: false,
          isConnecting: false,
          error: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ'
        }));
      };

    } catch (error) {
      console.error('‚ùå Failed to create WebSocket connection:', error);
      setState(prev => ({
        ...prev,
        isConnected: false,
        isConnecting: false,
        error: 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿßÿ™ÿµÿßŸÑ'
      }));
    }
  }, [user]);

  // ÿ•ŸäŸÇÿßŸÅ ping
  const stopPing = useCallback(() => {
    if (pingIntervalRef.current) {
      clearInterval(pingIntervalRef.current);
      pingIntervalRef.current = null;
    }
  }, []);

  // ÿ®ÿØÿ° ping ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ
  const startPing = useCallback(() => {
    stopPing();
    
    pingIntervalRef.current = setInterval(() => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ type: 'ping' }));
      }
    }, 30000); // ping ŸÉŸÑ 30 ÿ´ÿßŸÜŸäÿ©
  }, [stopPing]);

  // ÿ¨ÿØŸàŸÑÿ© ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ - ENHANCED with call stack debugging
  const scheduleReconnect = useCallback(() => {
    // DEBUG: Log call stack to find who's calling this
    console.error('üîç scheduleReconnect() called from:', new Error().stack);
    
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
    }

    const delay = Math.min(5000 * Math.pow(2, 0), 30000); // ÿ®ÿØÿ° ŸÖŸÜ 5 ÿ´ŸàÿßŸÜ
    console.log(`üîÑ Scheduling WebSocket reconnection in ${delay}ms`);

    reconnectTimerRef.current = setTimeout(() => {
      connect();
    }, delay);
  }, [connect]);

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ©
  const sendMessage = useCallback((message: WebSocketMessage) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
      console.log('üì§ WebSocket message sent:', message);
    } else {
      console.warn('‚ö†Ô∏è WebSocket not connected, cannot send message:', message);
    }
  }, []);

  // ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿ∑ŸÑÿ® ŸÖÿπŸäŸÜ
  const subscribeToOrderUpdates = useCallback((orderId: string) => {
    sendMessage({
      type: 'subscribe_order_updates',
      data: { orderId }
    });
  }, [sendMessage]);

  // ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑŸÉÿßÿ®ÿ™ŸÜ
  const updateDriverLocation = useCallback((latitude: number, longitude: number, orderId?: string) => {
    sendMessage({
      type: 'driver_location_update',
      data: {
        lat: latitude,
        lng: longitude,
        orderId,
        timestamp: Date.now(),
        speed: 0,
        heading: 0
      }
    });
  }, [sendMessage]);

  // ÿ®ÿ´ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
  const broadcastOrderStatusUpdate = useCallback((orderId: string, status: string, statusText: string, additionalData?: any) => {
    sendMessage({
      type: 'order_status_update',
      data: {
        orderId,
        status,
        statusText,
        timestamp: Date.now(),
        ...additionalData
      }
    });
  }, [sendMessage]);

  // ŸÇÿ∑ÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ
  const disconnect = useCallback(() => {
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
      reconnectTimerRef.current = null;
    }

    stopPing();

    if (wsRef.current) {
      wsRef.current.close(1000, 'Manual disconnect');
      wsRef.current = null;
    }

    setState({
      isConnected: false,
      isConnecting: false
    });
  }, [stopPing]);

  // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸäÿØŸàŸäÿßŸã
  const reconnect = useCallback(() => {
    disconnect();
    setTimeout(connect, 100);
  }, [disconnect, connect]);

  // ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸàÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ - RE-ENABLED after fixing auth issues
  useEffect(() => {
    console.log('üîó useWebSocket connection re-enabled - Authentication issues resolved');
    
    // Auto-connect when component mounts and user is authenticated
    if (user) {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [connect, disconnect]);

  // ÿ™ŸÜÿ∏ŸäŸÅ ÿπŸÜÿØ ÿ•ŸÑÿ∫ÿßÿ° ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÉŸàŸÜ
  useEffect(() => {
    return () => {
      if (reconnectTimerRef.current) {
        clearTimeout(reconnectTimerRef.current);
      }
      stopPing();
    };
  }, [stopPing]);

  return {
    state,
    sendMessage,
    subscribeToOrderUpdates,
    updateDriverLocation,
    broadcastOrderStatusUpdate,
    disconnect,
    reconnect
  };
}

// Hook ŸÑŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ŸÑŸÑÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿÆÿµÿµÿ©
export function useWebSocketEvent<T = any>(eventName: string, handler: (data: T) => void) {
  useEffect(() => {
    const eventHandler = (event: CustomEvent<T>) => {
      handler(event.detail);
    };

    window.addEventListener(eventName as any, eventHandler);

    return () => {
      window.removeEventListener(eventName as any, eventHandler);
    };
  }, [eventName, handler]);
}